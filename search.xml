<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>二叉树12.3</title>
    <url>/2023/12/03/%E4%BA%8C%E5%8F%89%E6%A0%9112-3/</url>
    <content><![CDATA[<h1 id="236-二叉树的最近公共祖先"><a href="#236-二叉树的最近公共祖先" class="headerlink" title="236.二叉树的最近公共祖先"></a>236.二叉树的最近公共祖先</h1><p>给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。</p>
<p>百度百科中最近公共祖先的定义为：“对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。”</p>
<span id="more"></span>

<p>例如，给定如下二叉树: root &#x3D; [3,5,1,6,2,0,8,null,null,7,4]</p>
<p><img src="https://code-thinking-1253855093.file.myqcloud.com/pics/20201016173414722.png" alt="236. 二叉树的最近公共祖先"></p>
<ul>
<li>找最近的公共祖先，首先想到能自底向上查就好了，那二叉树该怎么自底向上查询呢？<ul>
<li>当然是后序遍历了，后序遍历就是一个天然的回溯过程</li>
</ul>
</li>
<li>这道题目要遍历整棵树，因为 p 和 q 的位置是随机的，可能分别分布在根节点的两棵左右子树上</li>
<li>直接上代码</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">lowestCommonAncestor</span><span class="params">(TreeNode root, TreeNode p, TreeNode q)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span> || root == p || root == q) &#123; <span class="comment">// 递归结束条件</span></span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 后序遍历</span></span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">left</span> <span class="operator">=</span> lowestCommonAncestor(root.left, p, q);</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">right</span> <span class="operator">=</span> lowestCommonAncestor(root.right, p, q);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(left == <span class="literal">null</span> &amp;&amp; right == <span class="literal">null</span>) &#123; <span class="comment">// 若未找到节点 p 或 q</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(left == <span class="literal">null</span> &amp;&amp; right != <span class="literal">null</span>) &#123; <span class="comment">// 若找到一个节点</span></span><br><span class="line">            <span class="keyword">return</span> right;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(left != <span class="literal">null</span> &amp;&amp; right == <span class="literal">null</span>) &#123; <span class="comment">// 若找到一个节点</span></span><br><span class="line">            <span class="keyword">return</span> left;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123; <span class="comment">// 若找到两个节点</span></span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>通过画图来模拟程序的运行过程可以加深对此代码的理解</li>
</ul>
<hr>
<h1 id="235-二叉搜索树的最近公共祖先"><a href="#235-二叉搜索树的最近公共祖先" class="headerlink" title="235.二叉搜索树的最近公共祖先"></a>235.二叉搜索树的最近公共祖先</h1><p>给定一个二叉搜索树, 找到该树中两个指定节点的最近公共祖先。</p>
<p>百度百科中最近公共祖先的定义为：“对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。”</p>
<p>例如，给定如下二叉搜索树: root &#x3D; [6,2,8,0,4,7,9,null,null,3,5]</p>
<p><img src="https://code-thinking-1253855093.file.myqcloud.com/pics/20201018172243602.png" alt="235. 二叉搜索树的最近公共祖先"></p>
<ul>
<li>找的是在二叉搜索树中的最近公共祖先，要时刻记住，二叉搜索树的中序遍历是有序的，要充分利用这个特性</li>
<li>要找p 和 q 的公共祖先，我们可以从上到下迭代遍历，<strong>当第一次遇到节点的值是在[p,q]之间后，这个节点一定就是最近的公共祖先了</strong>。这也正是最巧妙的地方</li>
<li>可以模拟来论证，当 p &#x3D; 0， q &#x3D; 5时，从根节点开始遍历，遍历到结点2时，可以发现2在p和q之间，此时如果继续往下，向左遍历，那么结点2会错过成为5的祖先。</li>
<li>直接上代码</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">lowestCommonAncestor</span><span class="params">(TreeNode root, TreeNode p, TreeNode q)</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (root.val &gt; p.val &amp;&amp; root.val &gt; q.val) &#123;</span><br><span class="line">                root = root.left;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (root.val &lt; p.val &amp;&amp; root.val &lt; q.val) &#123;</span><br><span class="line">                root = root.right;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>迭代法的代码看上去可读性高些，递归法看上去更简便些</li>
</ul>
<hr>
<h1 id="每日一题-1423-可获得的最大点数"><a href="#每日一题-1423-可获得的最大点数" class="headerlink" title="每日一题 1423.可获得的最大点数"></a>每日一题 1423.可获得的最大点数</h1><ul>
<li><p>几张卡牌 <strong>排成一行</strong>，每张卡牌都有一个对应的点数。点数由整数数组 <code>cardPoints</code> 给出。每次行动，你可以从行的开头或者末尾拿一张卡牌，最终你必须正好拿 <code>k</code> 张卡牌。你的点数就是你拿到手中的所有卡牌的点数之和。给你一个整数数组 <code>cardPoints</code> 和整数 <code>k</code>，请你返回可以获得的最大点数。</p>
</li>
<li><p>解题思路</p>
<ul>
<li>每次都只能从两头取牌，看到题目首先想到每次取两头中最大的牌，最后的结果不就是最大的结果了吗？这种想法显然太稚嫩了</li>
<li>因为你不知道左右两边中间的牌是否更大，简单来说就是这样（5，1，1000，2），你只能取两张牌（k&#x3D;2），如果每次都取两边最大的，那么最后的大牌1000，就取不到了。</li>
<li>翻看题解，主要有两种思路，一种是前缀和，一种是滑动窗口。后者的思路比较能让笔者接收，属于是鄙人的舒适区了。</li>
<li>先来看滑动窗口。题目不是要求最后的最大值吗，我直接整一个滑动窗口从头开始遍历，滑动窗口的长度为牌数减去最后取得的牌数（len &#x3D; length - k），遍历完成后得到最小的滑动窗口值（min），那么用整幅牌的总和sum减去这个min值，就可以求得最终手里牌的最大值。很巧妙，逆向思维加个滑动窗口。</li>
<li>直接上代码</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxScore</span><span class="params">(<span class="type">int</span>[] cardPoints, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> cardPoints.length, len = n - k;</span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>, cur = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">            sum += cardPoints[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; len; i++)&#123;</span><br><span class="line">            cur += cardPoints[i];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">min</span> <span class="operator">=</span> cur;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> len; i &lt; n; i++)&#123;</span><br><span class="line">            cur = cur + cardPoints[i] - cardPoints[i - len];</span><br><span class="line">            min = Math.min(min, cur);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> sum - min;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>另一种解法：前缀和</p>
</li>
<li><p>前缀和的概念有些遗忘了，直接上代码</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxScore</span><span class="params">(<span class="type">int</span>[] cardPoints, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> cardPoints.length;</span><br><span class="line">        <span class="type">int</span> []pre = <span class="keyword">new</span> <span class="title class_">int</span>[len+<span class="number">1</span>]; pre[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; len;i++)&#123;</span><br><span class="line">            pre[i+<span class="number">1</span>] = cardPoints[i] + pre[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt;= k;i++)&#123;</span><br><span class="line">            max = Math.max(max, pre[i] + pre[len] - pre[len-k+i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">作者：imcover</span><br><span class="line">链接：https:<span class="comment">//leetcode.cn/problems/maximum-points-you-can-obtain-from-cards/solutions/220256/qian-zhui-he-xie-fa-by-imcover/</span></span><br><span class="line">来源：力扣（LeetCode）</span><br><span class="line">著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>算法</category>
      </categories>
  </entry>
  <entry>
    <title>2.1 CPU是如何执行程序的</title>
    <url>/2023/12/06/2-1-CPU%E6%98%AF%E5%A6%82%E4%BD%95%E6%89%A7%E8%A1%8C%E7%A8%8B%E5%BA%8F%E7%9A%84/</url>
    <content><![CDATA[<ul>
<li>首先提出三个问题：<ul>
<li>一条简单的代码 <code>a = 1 + 2</code> 是怎么被CPU执行起来的呢？</li>
<li>安装软件时，有32位和64位供我们选择，这两者的区别是什么呢？再者，32位的操作系统可以在64位的电脑上运行吗？反过来能运行吗？</li>
<li>我们知道CPU通常分为32位和64位，那么64位相对于32位的优势在哪？64位的CPU性能一定比32位CPU高很多吗？</li>
<li>这些问题都会在本文中得到解答</li>
</ul>
</li>
</ul>
<span id="more"></span>

<ul>
<li><p>最经典的冯诺依曼模型</p>
<ul>
<li><p>分为五个部分：运算器、控制器、存储器，输入、输出设备</p>
<p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost4/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Von_Neumann_architecture.svg" alt="img"></p>
</li>
<li><p>其中，是<strong>总线</strong>将这五个部件给联系起来的</p>
</li>
</ul>
<p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost2/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E7%A8%8B%E5%BA%8F%E6%89%A7%E8%A1%8C/%E5%86%AF%E8%AF%BA%E4%BE%9D%E6%9B%BC%E6%A8%A1%E5%9E%8B.png" alt="img"></p>
<ul>
<li>接下来逐一介绍这些部件<ul>
<li>内存<ul>
<li>我们的程序和数据都是存储在内存中的，存储的区域是线性的</li>
<li>存储的基本单位是字节（byte），一个字节等于8位（8个bit），每一个字节对应一个内存地址</li>
<li>可以理解为一个数组，内存地址都是从0开始编号的，所以内存读写任何一个数据的速度都是一样的</li>
</ul>
</li>
<li>中央处理器（CPU）<ul>
<li>回答文章开头的第三个问题，32位CPU和64位CPU的最主要区别是一次能计算多少字节数<ul>
<li>32位CPU一次可以计算4个字节（32&#x2F;8）</li>
<li>64位CPU一次可以计算8个字节（64&#x2F;8）</li>
</ul>
</li>
<li>其中，32位、64位有个专业名词，叫做CPU的位宽，即CPU一次可以计算的数据量</li>
<li>位宽越大，CPU一次计算的数据就越大</li>
<li>CPU里还有个叫寄存器的东西，它分为很多种类，每种的功能有所不同，作用极大</li>
<li>为什么需要寄存器呢？<ul>
<li>我们知道，数据是存储在我们内存里的，当我们CPU运算时，需要从内存中取数据，但是CPU与内存相距太远了，这会大大降低CPU的计算速度，而寄存器就在CPU里，CPU直接从里面取数据，这会快很多</li>
</ul>
</li>
<li>常见的寄存器种类<ul>
<li>通用寄存器，存要运算的数据</li>
<li>程序计数器，存将要执行的下一条指令的内存地址，注意存的是地址</li>
<li>指令寄存器，存的是指令本身</li>
</ul>
</li>
</ul>
</li>
<li>总线<ul>
<li>地址总线，传输指定CPU要操作的内存地址</li>
<li>数据总线，传输内存的数据</li>
<li>控制总线，发送和接受信号</li>
<li>CPU读写数据的过程，一般是这样的：首先通过地址总线指定内存的地址，然后通过控制总线决定是读命令还是写命令，最后通过数据总线传输数据</li>
</ul>
</li>
<li>输入输出设备<ul>
<li>输入设备向计算机输入数据，计算机经过计算后，把数据输出给输出设备。期间，如果输入设备是键盘，按下按键时是需要和 CPU 进行交互的，这时就需要用到控制总线了。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>线路位宽与CPU位宽</p>
<ul>
<li>串行：数据在一条线路上一位一位地传输</li>
<li>那么想多穿一些数据，就要增加线路，即并行</li>
<li>那么要增加多少条线路呢？其实，线路的位宽（就是多少条线路）最好一次就能访问到所有的内存地址，比如内存有<code>4G</code>，那么内存地址应该有<code>32位</code>,则需要32条线路</li>
<li>以上就是线路位宽，接下来看CPU位宽</li>
<li>CPU位宽最后不要小于线路位宽，最好相等地来搭配（32位CPU搭配32位宽的线路）</li>
<li>回答第三个问题：那么64位相对于32位的优势在哪？64位的CPU性能一定比32位CPU高很多吗？   <ul>
<li><strong>如果计算的数额不超过 32 位数字的情况下，32 位和 64 位 CPU 之间没什么区别的，只有当计算超过 32 位数字的情况下，64 位的优势才能体现出来</strong>。</li>
</ul>
</li>
</ul>
</li>
<li><p>程序执行的基本过程</p>
<ul>
<li>第一步，CPU 读取「程序计数器」的值，这个值是指令的内存地址，然后 CPU 的「控制单元」操作「地址总线」指定需要访问的内存地址，接着通知内存设备准备数据，数据准备好后通过「数据总线」将指令数据传给 CPU，CPU 收到内存传来的数据后，将这个指令数据存入到「指令寄存器」。</li>
<li>第二步，「程序计数器」的值自增，表示指向下一条指令。这个自增的大小，由 CPU 的位宽决定，比如 32 位的 CPU，指令是 4 个字节，需要 4 个内存地址存放，因此「程序计数器」的值会自增 4；</li>
<li>第三步，CPU 分析「指令寄存器」中的指令，确定指令的类型和参数，如果是计算类型的指令，就把指令交给「逻辑运算单元」运算；如果是存储类型的指令，则交由「控制单元」执行；</li>
<li>简单总结：CPU会根据程序计数器里的内存地址，从内存中把指令读取到指令寄存器里面执行，然后读取下一条指令</li>
<li>CPU 从程序计数器读取指令、到执行、再到下一条指令，这个过程会不断循环，直到程序执行结束，这个不断循环的过程被称为 <strong>CPU 的指令周期</strong>。</li>
</ul>
</li>
<li><p>a &#x3D; 1 + 2 执行过程</p>
<ul>
<li><p>首先 <code>a = 1 + 2</code> 这个字符串会被编译为汇编代码，然后再被翻译成机器码，机器码就是由0和1组成的机器语言，机器只认识机器码</p>
</li>
<li><p>在编译这段程序的过程中，编译器发现1和2是数据，于是将这两个数存入内存的数据段（数据（<em>数据段</em>）和指令（<em>正文段</em>）在内存中是分区域存放的）</p>
<p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost2/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E7%A8%8B%E5%BA%8F%E6%89%A7%E8%A1%8C/%E6%95%B0%E6%8D%AE%E6%AE%B5%E4%B8%8E%E6%AD%A3%E6%96%87%E6%AE%B5.png" alt="img"></p>
</li>
<li><p>编译器会把 <code>a = 1 + 2</code> 翻译成 4 条指令，存放到正文段中。如图，这 4 条指令被存放到了 0x100 ~ 0x10c 的区域中：</p>
<ul>
<li><p>0x100 的内容是 <code>load</code> 指令将 0x200 地址中的数据 1 装入到寄存器 <code>R0</code>；</p>
</li>
<li><p>0x104 的内容是 <code>load</code> 指令将 0x204 地址中的数据 2 装入到寄存器 <code>R1</code>；</p>
</li>
<li><p>0x108 的内容是 <code>add</code> 指令将寄存器 <code>R0</code> 和 <code>R1</code> 的数据相加，并把结果存放到寄存器 <code>R2</code>；</p>
</li>
<li><p>0x10c 的内容是 <code>store</code> 指令将寄存器 <code>R2</code> 中的数据存回数据段中的 0x208 地址中，这个地址也就是变量 <code>a</code> 内存中的地址；</p>
<p>编译完成后，具体执行程序的时候，程序计数器会被设置为 0x100 地址，然后依次执行这 4 条指令。</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>指令</p>
<ul>
<li><p>指令也是一串二进制的机器码，每条指令都会有对应的机器码</p>
</li>
<li><p>不同的CPU是有属于自己的一套指令集的，每一套指令集都是不同的。</p>
</li>
<li><p>以最简单的MIPS指令集为例子</p>
<ul>
<li><p>MIPS 的指令是一个 32 位的整数，高 6 位代表着操作码，表示这条指令是一条什么样的指令，剩下的 26 位不同指令类型所表示的内容也就不相同，主要有三种类型R、I 和 J。</p>
<p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost2/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E7%A8%8B%E5%BA%8F%E6%89%A7%E8%A1%8C/MIPS%E6%8C%87%E4%BB%A4%E9%9B%86.png" alt="img"></p>
<p>一起具体看看这三种类型的含义：</p>
<ul>
<li><em>R 指令</em>，用在算术和逻辑操作，里面有读取和写入数据的寄存器地址。如果是逻辑位移操作，后面还有位移操作的「位移量」，而最后的「功能码」则是再前面的操作码不够的时候，扩展操作码来表示对应的具体指令的；</li>
<li><em>I 指令</em>，用在数据传输、条件分支等。这个类型的指令，就没有了位移量和功能码，也没有了第三个寄存器，而是把这三部分直接合并成了一个地址值或一个常数；</li>
<li><em>J 指令</em>，用在跳转，高 6 位之外的 26 位都是一个跳转后的地址；</li>
</ul>
</li>
</ul>
</li>
<li><p>把前面例子的这条指令：「<code>add</code> 指令将寄存器 <code>R0</code> 和 <code>R1</code> 的数据相加，并把结果放入到 <code>R2</code>」，翻译成机器码。</p>
<p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost2/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E7%A8%8B%E5%BA%8F%E6%89%A7%E8%A1%8C/add%E7%9A%84MIPS%E6%8C%87%E4%BB%A4.png" alt="img"></p>
<p>加和运算 add 指令是属于 R 指令类型：</p>
<ul>
<li>add 对应的 MIPS 指令里操作码是 <code>000000</code>，以及最末尾的功能码是 <code>100000</code>，这些数值都是固定的，查一下 MIPS 指令集的手册就能知道的；</li>
<li>rs 代表第一个寄存器 R0 的编号，即 <code>00000</code>；</li>
<li>rt 代表第二个寄存器 R1 的编号，即 <code>00001</code>；</li>
<li>rd 代表目标的临时寄存器 R2 的编号，即 <code>00010</code>；</li>
<li>因为不是位移操作，所以位移量是 <code>00000</code></li>
</ul>
</li>
<li><p>编译器在编译程序的时候，会构造指令，这个过程叫做指令的编码。CPU 执行程序的时候，就会解析指令，这个过程叫作指令的解码。</p>
</li>
<li><p>现代大多数 CPU 都使用来流水线的方式来执行指令，所谓的流水线就是把一个任务拆分成多个小任务，于是一条指令通常分为 4 个阶段，称为 4 级流水线，如下图：</p>
<p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost2/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E7%A8%8B%E5%BA%8F%E6%89%A7%E8%A1%8C/CPU%E6%8C%87%E4%BB%A4%E5%91%A8%E6%9C%9F.png" alt="img"></p>
<p>四个阶段的具体含义：</p>
<ol>
<li>CPU 通过程序计数器读取对应内存地址的指令，这个部分称为 <strong>Fetch（取得指令）</strong>；</li>
<li>CPU 对指令进行解码，这个部分称为 <strong>Decode（指令译码）</strong>；</li>
<li>CPU 执行指令，这个部分称为 <strong>Execution（执行指令）</strong>；</li>
<li>CPU 将计算结果存回寄存器或者将寄存器的值存入内存，这个部分称为 <strong>Store（数据回写）</strong>；</li>
</ol>
</li>
<li><p>上述四个阶段，就是指令周期</p>
</li>
</ul>
</li>
<li><p>指令的执行速度</p>
<ul>
<li><p>公式</p>
<p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost2/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E7%A8%8B%E5%BA%8F%E6%89%A7%E8%A1%8C/%E7%A8%8B%E5%BA%8F%E7%9A%84CPU%E6%89%A7%E8%A1%8C%E6%97%B6%E9%97%B4%E5%85%AC%E5%BC%8F2.png" alt="img"></p>
</li>
<li><p>要想程序跑的更快，优化这三者即可：</p>
<ul>
<li><em>指令数</em>，表示执行程序所需要多少条指令，以及哪些指令。这个层面是基本靠编译器来优化，毕竟同样的代码，在不同的编译器，编译出来的计算机指令会有各种不同的表示方式。</li>
<li><em>每条指令的平均时钟周期数 CPI</em>，表示一条指令需要多少个时钟周期数，现代大多数 CPU 通过流水线技术（Pipeline），让一条指令需要的 CPU 时钟周期数尽可能的少；</li>
<li><em>时钟周期时间</em>，表示计算机主频，取决于计算机硬件。有的 CPU 支持超频技术，打开了超频意味着把 CPU 内部的时钟给调快了，于是 CPU 工作速度就变快了，但是也是有代价的，CPU 跑的越快，散热的压力就会越大，CPU 会很容易奔溃。</li>
</ul>
</li>
</ul>
</li>
<li><p>总结</p>
<ul>
<li>最后回答开头的问题</li>
<li>64 位相比 32 位 CPU 的优势在哪吗？64 位 CPU 的计算性能一定比 32 位 CPU 高很多吗？<ul>
<li>64位CPU能一次计算超过32位的数字，而32位CPU要计算超过32位的数字，则需要分多步骤进行计算，效率低，但是大部分应用程序很少会计算那么大的数字，所以<strong>只有运算大数字的时候，64 位 CPU 的优势才能体现出来，否则和 32 位 CPU 的计算性能相差不大</strong>。</li>
</ul>
</li>
<li>软件的 32 位和 64 位之间的区别吗？再来 32 位的操作系统可以运行在 64 位的电脑上吗？64 位的操作系统可以运行在 32 位的电脑上吗？如果不行，原因是什么？<ul>
<li>64位和32位的指令，实际代表的是指令是64位还是32位的：<ul>
<li>如果 32 位指令在 64 位机器上执行，需要一套兼容机制，就可以做到兼容运行了。但是<strong>如果 64 位指令在 32 位机器上执行，就比较困难了，因为 32 位的寄存器存不下 64 位的指令</strong>；</li>
<li>操作系统其实也是一种程序，我们也会看到操作系统会分成 32 位操作系统、64 位操作系统，其代表意义就是操作系统中程序的指令是多少位，比如 64 位操作系统，指令也就是 64 位，因此不能装在 32 位机器上。</li>
</ul>
</li>
<li>总之，硬件的32位和64位指的是CPU的位宽，软件的32位和64位指的是指令的位宽</li>
</ul>
</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>图解系统</category>
      </categories>
  </entry>
</search>
